fout = 0.35,
am.amps = c(1, 2, 3, 2, 0.1, 2, 3, 3, 2, 1)
)
# extract wave object and selection table
simulated_2 <- sim_2$wave
sim2_sel_table <- sim_2$selec.table
# plot spectrogram
label_spectro(wave = simulated_2, envelope = TRUE)
open_wd(tempdir())
# get mean structure template
template <-
get_templates(reference = lbh1_reference, path = tempdir())
#load package
library(ohun)
library(tuneR)
library(seewave)
library(warbleR)
data(lbh2)
data(lbh1)
data(lbh_reference)
# for spectrograms
par(mar = c(5, 4, 2, 2) + 0.1)
stopifnot(require(knitr))
options(width = 90)
opts_chunk$set(
comment = NA,
message = FALSE,
warning = FALSE,
# eval = if (isTRUE(exists("params"))) params$EVAL else FALSE,
dev = "jpeg",
dpi = 100,
fig.asp = 0.4,
fig.width = 6.5,
out.width = "100%",
fig.align = "center"
)
# load example data
data("lbh1", "lbh2", "lbh_reference")
lbh_reference
# save sound file
writeWave(lbh1, file.path(tempdir(), "lbh1.wav"))
# save sound file
writeWave(lbh2, file.path(tempdir(), "lbh2.wav"))
# print spectrogram
label_spectro(
wave = lbh1,
reference = lbh_reference[lbh_reference$sound.files == "lbh1.wav",],
hop.size = 10,
ovlp = 50,
flim = c(1, 10)
)
# print spectrogram
label_spectro(
wave = lbh2,
reference = lbh_reference[lbh_reference$sound.files == "lbh2.wav",],
hop.size = 10,
ovlp = 50,
flim = c(1, 10)
)
lbh1_reference <-
lbh_reference[lbh_reference$sound.files == "lbh1.wav",]
# diagnose
diagnose_detection(reference = lbh1_reference,
detection = lbh1_reference)[, c(1:4, 8:10)]
# create new table
lbh1_detection <- lbh1_reference[3:9, ]
# print spectrogram
label_spectro(
wave = lbh1,
reference = lbh1_reference,
detection = lbh1_detection,
hop.size = 10,
ovlp = 50,
flim = c(1, 10)
)
# diagnose
diagnose_detection(reference = lbh1_reference,
detection = lbh1_detection)[, c(1:4, 8:10)]
# print spectrogram
label_spectro(
wave = lbh1,
detection = lbh1_reference,
reference = lbh1_detection,
hop.size = 10,
ovlp = 50,
flim = c(1, 10)
)
# diagnose
diagnose_detection(reference = lbh1_detection,
detection = lbh1_reference)[, c(1:4, 8:10)]
# create new table
lbh1_detection <- lbh1_reference
# add 'noise' to start
set.seed(18)
lbh1_detection$start <-
lbh1_detection$start + rnorm(nrow(lbh1_detection),
mean = 0, sd = 0.1)
## print spectrogram
label_spectro(
wave = lbh1,
reference = lbh1_reference,
detection = lbh1_detection,
hop.size = 10,
ovlp = 50,
flim = c(1, 10)
)
# diagnose
diagnose_detection(reference = lbh1_reference,
detection = lbh1_detection)
# diagnose with time diagnostics
diagnose_detection(reference = lbh1_reference[-1, ], detection = lbh1_detection[-10, ], time.diagnostics = TRUE)
# diagnose by sound file
diagnostic <-
diagnose_detection(reference = lbh1_reference,
detection = lbh1_detection,
by.sound.file = TRUE)
diagnostic
# summarize
summarize_diagnostic(diagnostic)
# plot spectrogram and envelope
label_spectro(
wave = cutw(
lbh1,
from = 0,
to = 1.5,
output = "Wave"
),
ovlp = 90,
hop.size = 10,
flim = c(0, 10),
envelope = TRUE
)
# install this package first if not installed
# install.packages("Sim.DiffProc")
#Creating vector for duration
durs <- rep(c(0.3, 1), 5)
set.seed(123)
freqs <- sample(c(3, 6), 10, replace = TRUE)
#Creating simulated song
set.seed(12)
simulated_1 <-
warbleR::simulate_songs(
n = 10,
durs = durs,
freqs = freqs,
sig2 = 0.1,
gaps = 0.5,
harms = 1,
bgn = 0.1,
freq.range = 2,
path = tempdir(),
file.name = "simulated_1",
selec.table = TRUE,
shape = "cos",
fin = 0.3,
fout = 0.35,
samp.rate = 18
)$wave
# plot spectrogram and envelope
label_spectro(wave = simulated_1,
env = TRUE,
fastdisp = TRUE)
# run detection
detection <-
energy_detector(
files = "simulated_1.wav",
bp = c(2, 8),
threshold = 50,
smooth = 150,
path = tempdir()
)
# plot spectrogram and envelope
label_spectro(
wave = simulated_1,
envelope = TRUE,
detection = detection,
threshold = 50
)
detection
# run detection
detection <-
energy_detector(
files = "simulated_1.wav",
bp = c(1, 8),
threshold = 50,
min.duration = 500,
smooth = 150,
path = tempdir()
)
# plot spectrogram
label_spectro(wave = simulated_1, detection = detection)
# run detection
detection <-
energy_detector(
files = "simulated_1.wav",
bp = c(1, 8),
threshold = 50,
smooth = 150,
max.duration = 500,
path = tempdir()
)
# plot spectrogram
label_spectro(wave = simulated_1,  detection = detection)
# Detecting
detection <-
energy_detector(
files = "simulated_1.wav",
bp = c(5, 8),
threshold = 50,
smooth = 150,
path = tempdir()
)
# plot spectrogram
label_spectro(wave = simulated_1,  detection = detection)
#Creating simulated song
set.seed(12)
#Creating vector for duration
durs <- rep(c(0.3, 1), 5)
sim_2 <-
simulate_songs(
n = 10,
durs = durs,
freqs = freqs,
sig2 = 0.1,
gaps = 0.5,
harms = 1,
bgn = 0.1,
freq.range = 2,
path = tempdir(),
file.name = "simulated_2",
selec.table = TRUE,
shape = "cos",
fin = 0.3,
fout = 0.35,
am.amps = c(1, 2, 3, 2, 0.1, 2, 3, 3, 2, 1),
samp.rate = 18
)
# extract wave object and selection table
simulated_2 <- sim_2$wave
sim2_sel_table <- sim_2$selec.table
# plot spectrogram
label_spectro(wave = simulated_2, envelope = TRUE)
# detect sounds
detection <- energy_detector(files = "simulated_2.wav", threshold = 50, path = tempdir())
# plot spectrogram
label_spectro(wave = simulated_2, envelope = TRUE, threshold = 50, detection = detection)
# detect sounds
detection <-
energy_detector(
files = "simulated_2.wav",
threshold = 50,
min.duration = 1,
path = tempdir(),
hold.time = 200
)
# plot spectrogram
label_spectro(
wave = simulated_2,
envelope = TRUE,
threshold = 50,
detection = detection
)
# detect sounds
detection <-
energy_detector(
files = "simulated_2.wav",
threshold = 50,
min.duration = 1,
path = tempdir(),
smooth = 350
)
# plot spectrogram
label_spectro(
wave = simulated_2,
envelope = TRUE,
threshold = 50,
detection = detection,
smooth = 350
)
optim_detection <-
optimize_energy_detector(
reference = sim2_sel_table,
files = "simulated_2.wav",
threshold = 50,
min.duration = 1,
path = tempdir(),
smooth = c(100, 250, 350)
)
optim_detection[, c(1, 2:5, 7:12, 17:18)]
feature_reference(reference = lbh_reference, path = tempdir())
# get mean structure template
template <-
get_templates(reference = lbh1_reference, path = tempdir())
blogdown::build_site()
# package to install other packages from github
if (!requireNamespace("sketchy"))
install.packages("sketchy")
# load package
library(sketchy)
# install/load packages
load_packages(packages = c(
"pracma",
"Sim.DiffProc",
"bioacoustics",
"phonTools",
"soundgen",
"audio",
"ggalign",
github = "maRce10/warbleR",
github = "maRce10/Rraven",
github = "maRce10/ohun",
github = "maRce10/suwo",
github = "maRce10/baRulho",
github = "maRce10/dynaSpec",
github = "maRce10/PhenotypeSpace"
)
)
quarto::quarto_serve()
quarto::quarto_preview()
data("Phae.long.est")
Phae.long.est
data("Phae.long.est")
library(warbleR)
data("Phae.long.est")
library(NatureSounds)
data("Phae.long.est")
lbh.est
# Chunk 1: clean session
knitr::opts_chunk$set(dpi = 200)
library(warbleR)
library(kableExtra)
library(viridis)
library(ggplot2)
library(ggalign)
library(PhenotypeSpace)
# Chunk 3
warbleR_options(wav.path = "./examples/", flim = c(1, 10), wl = 200, ovlp = 90, pb = FALSE)
data(lbh_selec_table)
kbl <- kable(lbh_selec_table, align = "c", row.names = F,  format = "html")
kbl <- kable_styling(kbl, bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, font_size = 11)
scroll_box(kbl, width = "808px",
box_css = "border: 1px solid #ddd; padding: 5px; ", extra_css = NULL)
# Chunk 5
#| echo: false
#| out.width: "100%"
knitr::include_graphics("./images/Catalog_p1.jpeg")
# Chunk 7
sp <- spectro_analysis(lbh_selec_table)
kbl <- kable(sp, align = "c", row.names = F,  format = "html")
kbl <- kable_styling(kbl, bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, font_size = 11)
scroll_box(kbl, width = "808px",
box_css = "border: 1px solid #ddd; padding: 5px; ", extra_css = NULL)
# Chunk 9
#| echo: false
# run principal components
pca <- prcomp(sp[, -c(1, 2)], scale = TRUE)
# extract first 2 PCs
sp_pcs <- data.frame(sp[, 1:2], pca$x[, 1:2])
kbl <- kable(sp_pcs, align = "c", row.names = F,  format = "html")
kbl <- kable_styling(kbl, bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, font_size = 11)
scroll_box(kbl, width = "808px",
box_css = "border: 1px solid #ddd; padding: 5px; ", extra_css = NULL)
# Chunk 10
ggplot(sp_pcs,
aes(
x = PC1,
y = PC2,
color = sound.files,
shape =  sound.files
)) +
geom_point(size = 5) +
scale_color_viridis_d(option = "G",
end = 0.9,
direction = -1) +
theme_classic() +
labs(x = "PC1", y = "PC2") +
theme(legend.position = "right")
# Chunk 12
cc <- mfcc_stats(X = lbh_selec_table)
kbl <- kable(cc, align = "c", row.names = F,  format = "html")
kbl <- kable_styling(kbl, bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, font_size = 11)
scroll_box(kbl, width = "808px",
box_css = "border: 1px solid #ddd; padding: 5px; ", extra_css = NULL)
# Chunk 14
#| echo: false
# run principal components
pca <- prcomp(cc[, -c(1, 2)], scale = TRUE)
# extract first 2 PCs
cc_pcs <- data.frame(cc[, 1:2], pca$x[, 1:2])
kbl <- kable(cc_pcs, align = "c", row.names = F,  format = "html")
kbl <- kable_styling(kbl, bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, font_size = 11)
scroll_box(kbl, width = "808px",
box_css = "border: 1px solid #ddd; padding: 5px; ", extra_css = NULL)
# Chunk 15
ggplot(cc_pcs,
aes(
x = PC1,
y = PC2,
color = sound.files,
shape =  sound.files
)) +
geom_point(size = 5) +
scale_color_viridis_d(option = "G",
end = 0.9,
direction = -1) +
theme_classic() +
labs(x = "PC1", y = "PC2") +
theme(legend.position = "right")
# Chunk 17
xcor <- cross_correlation(X = lbh_selec_table)
kbl <- kable(xcor, align = "c", row.names = TRUE,  format = "html")
kbl <- kable_styling(kbl, bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, font_size = 11)
scroll_box(kbl, width = "808px",
box_css = "border: 1px solid #ddd; padding: 5px; ", extra_css = NULL)
# present xcor as a heatmap using ggplot2
ggheatmap(xcor) +
scale_fill_viridis_c(
option = "G",
direction = 1,
begin = 0.1,
end = 0.8
) +
theme(axis.text.x = element_text(angle = 90))
xcor
xcor
xcor
ggheatmap(xcor)
# present xcor as a heatmap using ggplot2
ggheatmap(as.dist(xcor)) +
scale_fill_viridis_c(
option = "G",
direction = 1,
begin = 0.1,
end = 0.8
) +
theme(axis.text.x = element_text(angle = 90))
# present xcor as a heatmap using ggplot2
ggalign::ggheatmap((xcor)) +
scale_fill_viridis_c(
option = "G",
direction = 1,
begin = 0.1,
end = 0.8
) +
theme(axis.text.x = element_text(angle = 90))
ggheatmap(matrix(rnorm(81), nrow = 9L))
ggheatmap(letters)
ggheatmap(1:10)
# present xcor as a heatmap using ggplot2
ggalign::heatmap_layout((xcor)) +
scale_fill_viridis_c(
option = "G",
direction = 1,
begin = 0.1,
end = 0.8
) +
theme(axis.text.x = element_text(angle = 90))
ggheatmap(1:10)
library(ggalign)
ggheatmap(1:10)
# present xcor as a heatmap using ggplot2
ggheatmap::ggheatmap((xcor)) +
scale_fill_viridis_c(
option = "G",
direction = 1,
begin = 0.1,
end = 0.8
) +
theme(axis.text.x = element_text(angle = 90))
install.packages("ggheatmap")
# present xcor as a heatmap using ggplot2
ggheatmap::ggheatmap((xcor)) +
scale_fill_viridis_c(
option = "G",
direction = 1,
begin = 0.1,
end = 0.8
) +
theme(axis.text.x = element_text(angle = 90))
URL <- "https://github.com/maRce10/OTS_BIR_2024/raw/master/data/extended.selection.table.araya-salas.et.al.2017.bioacoustics.100.sels.rds"
dat <- readRDS(gzcon(url(URL)))
quarto::quarto_preview()
rlang::last_trace()
library(suwo)
phae_his <- query_xenocanto(term = 'Phaethornis hispidus')
song_phae_his <- phae_his[grep("song", ignore.case = TRUE, phae_his$vocalization.type), ]
map_locations(song_phae_his)
head(song_phae_his)
phae_his <- query_xenocanto(term = 'Phaethornis hispidus')
phae_his <- query_xenocanto(term = 'Phaethornis hispidus', all_data = TRUE)
song_phae_his <- phae_his[grep("song", ignore.case = TRUE, phae_his$vocalization_type), ]
song_phae_his
map_locations(song_phae_his)
pg <- query_xenocanto(qword = 'Phaethornis guy', all_data = TRUE)
pg <- query_xenocanto('Phaethornis guy', all_data = TRUE)
song_pg <- pg[grepl("song", ignore.case = TRUE, pg$Vocalization_type) & pg$quality == "A", ]
song_pg
song_pg <- pg[grepl("song", ignore.case = TRUE, pg$vocalization_type) & pg$quality == "A", ]
song_pg
song_pg
song_pg$locality
# remove 1 site from Colombia to have a few samples per country
song_pg <- song_pg[song_pg$locality != "Suaita, Santander", ]
write.csv(song_pg, file = "./examples/p_guy/metadata_p_guy_XC.csv", row.names = FALSE)
map_locations(song_pg)
viridis::mako(10, alpha = 0.5)
viridis::mako(10, alpha = 0.2)
viridis::mako(10, alpha = 0.9)
viridis::mako(10, alpha = 0.97)
viridis::mako(10, alpha = 0.7)
viridis::mako(10, alpha = 0.6)
viridis::mako(10, alpha = 0.4)
